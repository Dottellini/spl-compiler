package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    // Apparently there is a cup bug that causes expected_token_ids() to return incorrect results on first call
    // This is why this call is inserted.
    this.expected_token_ids();
    
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right),
            this.symbl_name_from_id(currentToken.sym),
            this.expected_token_ids().stream().map(this::symbl_name_from_id).toList());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal List<GlobalDefinition> globalDefinitionsList;
non terminal GlobalDefinition globalDefinition;
non terminal TypeDefinition typeDec;
non terminal ArrayTypeExpression typeArrayDec;
non terminal ProcedureDefinition procDec; //Bis hier
non terminal procParameterList, procParameterListOrEmpty, procParameter, procInstructionList, procInstruction;
non terminal varDecList, varDec;
non terminal varName, varNameForMultiDimArray, varAssignment, ifStatement, whileLoop, blockStatement, procCall, ifFollower;
non terminal procParameterCallListOrEmpty, procParameterCall;
non terminal expression, comparisonOperation, comparisonOperators;
non terminal punktCalculation, strichCalculation, negationParenCalc, parenCalculation, calculationValue;

precedence left LT, LE, GT, GE, EQ, NE;
precedence left PLUS, MINUS;
precedence left STAR, SLASH;
precedence right ASGN;

start with program;

program ::= globalDefinitionsList:this {:RESULT = this;:};

globalDefinitionsList ::= globalDefinition:def globalDefinitionsList:list {: RESULT = list.add(new GlobalDefinition(new Position(defleft, defright), def)); :} //TODO: idk ob das geht mit der Liste, vielleicht wie unten machen?
                            | /* leer */ {:RESULT = list.add(new GlobalDefinition());:};
globalDefinition ::= typeDec:typeDec {:RESULT = typeDec;:}| procDec:procDec {:RESULT = procDec;:};

typeDec ::= TYPE IDENT:name EQ:op typeArrayDec:type SEMIC {:RESULT = new TypeDefinition(new Position(opleft, opright), name, type);:}
                | TYPE IDENT:name EQ:op IDENT:type SEMIC {:RESULT = new TypeDefinition(new Position(opleft, opright), name, new NamedTypeExpression(new Position(typeleft, typeright), type));:};
typeArrayDec ::= ARRAY LBRACK INTLIT:size RBRACK OF typeArrayDec:type {:RESULT = new ArrayTypeExpression(new Position(sizeleft, sizeright), size, type);:}
                | ARRAY LBRACK INTLIT:size RBRACK OF IDENT:type {:RESULT = new ArrayTypeExpression(new Position(sizeleft, sizeright), new NamedTypeExpression(new Position(typeleft, typeright), type));:};

procDec ::= PROC IDENT:name LPAREN procParameterListOrEmpty:params RPAREN LCURL varDecList:vars procInstructionList:procs RCURL {:RESULT = new ProcedureDefinition(new Position(nameleft, nameright), name, params, vars, procs);:};
////////////TODO Ka ob das so stimmt mit der Liste, muss maybe eine ListClass eingeführt werden
procParameterListOrEmpty ::= procParameterList:plist {:RESULT = new ArrayList<ParameterDefinition>().addAll(plist);:}
                            | /* leer */; //Man kann das nicht mit procParameterList verbinden, da man sonst (1, ) machen könnte, was nicht legal ist
procParameterList ::= procParameter:param {:RESULT = param;:}
                    | procParameter:param COMMA procParameterList:list {:RESULT = list.add(param);:};
///////////
procParameter ::= IDENT:name COLON IDENT:type {:RESULT = new ParameterDefinition(new Position(nameleft, nameright), name, new NamedTypeExpression(new Position(typeleft, typeright), type), false);:}
                    | REF IDENT:name COLON IDENT:type {:RESULT = new ParameterDefinition(new Position(nameleft, nameright), name, new NamedTypeExpression(new Position(typeleft, typeright), type), true);:};

varDecList ::= varDec varDecList | /* leer */;
varDec ::= VAR IDENT COLON typeArrayDec SEMIC | VAR IDENT COLON IDENT SEMIC;

procInstructionList ::= procInstruction procInstructionList | /* leer */;
procInstruction ::= varAssignment | ifStatement | whileLoop | blockStatement | procCall | SEMIC;

//Erstelle whileLoop, ifStatement, blockBody, varAssignment, procCall
varAssignment ::= varName ASGN expression SEMIC;
varName ::= IDENT | varNameForMultiDimArray LBRACK expression RBRACK;
varNameForMultiDimArray ::= IDENT | varNameForMultiDimArray LBRACK expression RBRACK; //Wird benötigt für multi dimensionale Arrays

ifStatement ::= IF LPAREN comparisonOperation RPAREN procInstruction ELSE procInstruction
                | IF LPAREN comparisonOperation RPAREN procInstruction;

whileLoop ::= WHILE LPAREN comparisonOperation RPAREN procInstruction;

blockStatement ::= LCURL procInstructionList RCURL;

procCall ::= IDENT LPAREN procParameterCallListOrEmpty RPAREN SEMIC;
procParameterCallListOrEmpty ::= procParameterCall | /* leer */;
procParameterCall ::= expression | expression COMMA procParameterCall;

comparisonOperation ::= expression comparisonOperators expression;
comparisonOperators ::= LT | LE | EQ | NE | GT | GE;

expression ::= strichCalculation;

strichCalculation ::= strichCalculation PLUS punktCalculation
                    | strichCalculation MINUS punktCalculation
                    | punktCalculation;

punktCalculation ::= punktCalculation STAR negationParenCalc
                   | punktCalculation SLASH negationParenCalc
                   | negationParenCalc;

negationParenCalc ::= MINUS parenCalculation | parenCalculation;

parenCalculation ::= LPAREN expression RPAREN | calculationValue;

calculationValue ::= varName | INTLIT;

